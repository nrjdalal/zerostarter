name: auto-labeler

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - canary
  pull_request_review:
    types: [submitted, dismissed]

concurrency: ${{ github.workflow }}-${{ github.event.pull_request.number }}

permissions:
  contents: read
  issues: write
  pull-requests: write

env:
  APPROVAL_THRESHOLD: "1"
  TARGET_BRANCH: "canary"

jobs:
  label-pr:
    runs-on: ubuntu-latest
    if: github.event.pull_request.base.ref == 'canary'

    steps:
      - name: Checkout PR head
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Label impacted packages/apps
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');

            const TARGET_BRANCH = process.env.TARGET_BRANCH;
            const pr = context.payload.pull_request;

            // Early exit if PR doesn't target the correct branch
            if (pr.base.ref !== TARGET_BRANCH) {
              console.log(`Skipping: PR targets ${pr.base.ref}, not ${TARGET_BRANCH}`);
              return;
            }

            // Configuration
            const topLevelDirs = ['api', 'packages', 'marketing', 'web'];
            const colorMap = {
              'api': '9333ea',       // purple
              'marketing': '10b981', // green
              'packages': '3b82f6',  // blue
              'web': 'f97316',       // orange
              'zero': '6b7280',      // gray - for files not in any package
            };

            const { number: prNumber } = pr;
            const { owner, repo } = context.repo;

            // Find all package.json files using globby via Bun
            let packageJsonPaths = [];
            try {
              // Write a temporary script to use globby
              const tempScript = `
                const { globby } = await import('globby');
                const paths = await globby(['**/package.json'], {
                  ignore: ['**/node_modules/**', '**/.git/**'],
                  absolute: false
                });
                console.log(JSON.stringify(paths));
              `;
              fs.writeFileSync('/tmp/find-packages.mjs', tempScript);
              const globbyOutput = execSync('bun /tmp/find-packages.mjs', {
                encoding: 'utf-8',
                cwd: process.cwd()
              });
              packageJsonPaths = JSON.parse(globbyOutput.trim());
              fs.unlinkSync('/tmp/find-packages.mjs');
            } catch (error) {
              // Fallback to find command if globby fails
              console.warn('globby failed, using find fallback:', error.message);
              try {
                const findOutput = execSync(
                  'find . -name "package.json" -type f -not -path "*/node_modules/*" -not -path "*/.git/*"',
                  { encoding: 'utf-8', cwd: process.cwd() }
                );
                packageJsonPaths = findOutput
                  .split('\n')
                  .filter(Boolean)
                  .map(p => p.replace(/^\.\//, ''));
              } catch (findError) {
                console.error('Error finding package.json files:', findError.message);
              }
            }

            console.log(`Found ${packageJsonPaths.length} package.json file(s)`);

            // Build a map: file path -> package directory
            // For each package.json, map all possible file paths that belong to it
            const pathToPackageMap = new Map();

            for (const packageJsonPath of packageJsonPaths) {
              const packageDir = path.dirname(packageJsonPath);
              const pathParts = packageDir.split('/').filter(Boolean);
              
              // Only process if in a tracked top-level directory
              if (pathParts.length >= 2 && topLevelDirs.includes(pathParts[0])) {
                const topLevel = pathParts[0];
                const packageName = pathParts[1];
                const label = `@${topLevel}/${packageName}`;
                
                // Store the package directory path for this label
                pathToPackageMap.set(packageDir, label);
                console.log(`Mapped ${packageDir} -> ${label}`);
              }
            }

            // Get all changed files in the PR
            const files = await github.paginate(
              github.rest.pulls.listFiles,
              { owner, repo, pull_number: prNumber, per_page: 100 }
            );

            // Helper function to find which package a file belongs to
            const findPackageForFile = (filePath) => {
              const pathParts = filePath.split('/').filter(Boolean);
              
              // Traverse up directories to find matching package
              for (let i = pathParts.length; i > 0; i--) {
                const dirPath = pathParts.slice(0, i).join('/');
                if (pathToPackageMap.has(dirPath)) {
                  return pathToPackageMap.get(dirPath);
                }
              }
              return null;
            };

            // Extract package/app labels from file paths
            const labelsToAdd = new Set();
            for (const file of files) {
              const pathParts = file.filename.split('/').filter(Boolean);
              const [topLevel] = pathParts;
              
              // Check if file is in a tracked top-level directory
              if (topLevelDirs.includes(topLevel)) {
                // Find the package this file belongs to
                const label = findPackageForFile(file.filename);
                
                if (label) {
                  labelsToAdd.add(label);
                } else {
                  // In tracked directory but no package.json found - add zero label
                  labelsToAdd.add('@zero');
                }
              } else {
                // Not in a tracked top-level directory (e.g., .github/scripts) - add zero label
                labelsToAdd.add('@zero');
              }
            }

            if (labelsToAdd.size === 0) {
              console.log('No matching package/app paths found.');
              return;
            }

            console.log(`Found ${labelsToAdd.size} package/app(s) to label: ${[...labelsToAdd].join(', ')}`);

            // Ensure labels exist (create if missing)
            for (const labelName of labelsToAdd) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: labelName });
              } catch (error) {
                if (error.status === 404) {
                  const category = labelName === '@zero' ? 'zero' : labelName.split('/')[0].substring(1);
                  const color = colorMap[category] || '6b7280';
                  const description = labelName === '@zero'
                    ? 'Files not belonging to any tracked package/app'
                    : `Auto-created label for ${labelName}`;
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: labelName,
                    color,
                    description
                  });
                  console.log(`Created label: ${labelName}`);
                } else {
                  throw error;
                }
              }
            }

            // Get current labels on the PR
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner,
              repo,
              issue_number: prNumber
            });

            // Find stale package labels to remove
            const toRemove = currentLabels
              .map(l => l.name)
              .filter(name => {
                if (!name.startsWith('@')) return false;
                // Handle @zero label
                if (name === '@zero') {
                  return !labelsToAdd.has(name);
                }
                // Handle @category/name labels
                if (!name.includes('/')) return false;
                const category = name.split('/')[0].substring(1);
                return (topLevelDirs.includes(category) || category === 'zero') && !labelsToAdd.has(name);
              });

            // Remove stale labels
            for (const name of toRemove) {
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: prNumber,
                  name
                });
                console.log(`Removed stale label: ${name}`);
              } catch (error) {
                console.warn(`Failed to remove label ${name}:`, error.message);
              }
            }

            // Add new labels
            if (labelsToAdd.size > 0) {
              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number: prNumber,
                labels: [...labelsToAdd]
              });
              console.log(`Added labels: ${[...labelsToAdd].join(', ')}`);
            }

      - name: Get approval count
        id: approvals
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          result-encoding: string
          script: |
            const TARGET_BRANCH = process.env.TARGET_BRANCH;
            const pr = context.payload.pull_request;

            if (pr.base.ref !== TARGET_BRANCH) {
              console.log(`Skipping: PR targets ${pr.base.ref}, not ${TARGET_BRANCH}`);
              return '0';
            }

            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            // Get each user's most recent review
            const latestReviewByUser = {};
            reviews
              .sort((a, b) => new Date(a.submitted_at) - new Date(b.submitted_at))
              .forEach(review => {
                if (review.user?.login) {
                  latestReviewByUser[review.user.login] = review;
                }
              });

            // Count approvals (only users whose latest review is APPROVED)
            const approvers = Object.values(latestReviewByUser)
              .filter(review => review.state === 'APPROVED')
              .map(review => review.user.login);

            const count = approvers.length;
            console.log(`Found ${count} approval(s) from: ${approvers.join(', ') || 'none'}`);
            return count.toString();

      - name: Apply dynamic approval label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const TARGET_BRANCH = process.env.TARGET_BRANCH;
            const pr = context.payload.pull_request;

            if (pr.base.ref !== TARGET_BRANCH) {
              console.log(`Skipping: PR targets ${pr.base.ref}, not ${TARGET_BRANCH}`);
              return;
            }

            const { owner, repo } = context.repo;
            const count = parseInt(`${{ steps.approvals.outputs.result }}`, 10) || 0;
            const required = parseInt(process.env.APPROVAL_THRESHOLD, 10);

            // Determine label name and color
            const labelName = count >= required ? 'APPROVED' : `${count}/${required}`;
            const color = count >= required ? '0e8a16' : 'd73a4a'; // green : red

            // Get existing labels
            const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
              owner,
              repo,
              issue_number: pr.number
            });

            // Remove old approval labels
            const approvalLabelPattern = /^\d+\/\d+$|^APPROVED$/;
            for (const label of existingLabels) {
              if (approvalLabelPattern.test(label.name) && label.name !== labelName) {
                try {
                  await github.rest.issues.removeLabel({
                    owner,
                    repo,
                    issue_number: pr.number,
                    name: label.name
                  });
                  console.log(`Removed old approval label: ${label.name}`);
                } catch (error) {
                  console.warn(`Failed to remove label ${label.name}:`, error.message);
                }
              }
            }

            // Ensure the label exists
            try {
              await github.rest.issues.getLabel({ owner, repo, name: labelName });
            } catch (error) {
              if (error.status === 404) {
                await github.rest.issues.createLabel({
                  owner,
                  repo,
                  name: labelName,
                  color,
                  description: count >= required
                    ? 'PR has met the required approvals'
                    : `PR has ${count} of ${required} required approvals`
                });
                console.log(`Created approval label: ${labelName}`);
              } else {
                throw error;
              }
            }

            // Add the label
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: pr.number,
              labels: [labelName]
            });
            console.log(`Applied approval label: ${labelName}`);
